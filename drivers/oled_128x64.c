/*
  SeeedOLED.cpp - SSD130x OLED Driver Library
  2011 Copyright (c) Seeed Technology Inc.  All right reserved.
 
  Author: Visweswara R
  
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "oled_128x64.h"
#include "serial_bitbang.h"
#include "timer_a0.h"

// 8x8 Font ASCII 32 - 127 Implemented
// Users can modify this to support more characters(glyphs)
// BasicFont is placed in code memory.

// This font be freely used without any restriction(It is placed in public domain)
const unsigned char BasicFont[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00},
    {0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00},
    {0x00, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00},
    {0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00},
    {0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00},
    {0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00, 0x00},
    {0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0xA0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00},
    {0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00},
    {0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00},
    {0x00, 0x62, 0x51, 0x49, 0x49, 0x46, 0x00, 0x00},
    {0x00, 0x22, 0x41, 0x49, 0x49, 0x36, 0x00, 0x00},
    {0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00},
    {0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00},
    {0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00},
    {0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00},
    {0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},
    {0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00},
    {0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xAC, 0x6C, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},
    {0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00},
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},
    {0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00},
    {0x00, 0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00},
    {0x00, 0x7E, 0x09, 0x09, 0x09, 0x7E, 0x00, 0x00},
    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},
    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00},
    {0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00},
    {0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00},
    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00},
    {0x00, 0x3E, 0x41, 0x41, 0x51, 0x72, 0x00, 0x00},
    {0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00},
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00},
    {0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00},
    {0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},
    {0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00},
    {0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00},
    {0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00},
    {0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00},
    {0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00},
    {0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00},
    {0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00},
    {0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00},
    {0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00},
    {0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00},
    {0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00},
    {0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00},
    {0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00},
    {0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00},
    {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00},
    {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00},
    {0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00},
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00},
    {0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00},
    {0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00, 0x00},
    {0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00},
    {0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00},
    {0x00, 0x08, 0x7E, 0x09, 0x02, 0x00, 0x00, 0x00},
    {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00},
    {0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},
    {0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00},
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00},
    {0x00, 0x7C, 0x08, 0x04, 0x7C, 0x00, 0x00, 0x00},
    {0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00},
    {0x00, 0xFC, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00},
    {0x00, 0x18, 0x24, 0x24, 0xFC, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x7C, 0x08, 0x04, 0x00, 0x00, 0x00},
    {0x00, 0x48, 0x54, 0x54, 0x24, 0x00, 0x00, 0x00},
    {0x00, 0x04, 0x7F, 0x44, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x3C, 0x40, 0x40, 0x7C, 0x00, 0x00, 0x00},
    {0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00},
    {0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00},
    {0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00},
    {0x00, 0x1C, 0xA0, 0xA0, 0x7C, 0x00, 0x00, 0x00},
    {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00},
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00},
    {0x00, 0x02, 0x05, 0x05, 0x02, 0x00, 0x00, 0x00}
};

uint8_t oled_128x64_init(void)
{
    uint8_t rv;
    rv = oled_128x64_send_command(SeeedOLED_Display_Off_Cmd);
    timer_a0_delay(5000);
    rv += oled_128x64_send_command(SeeedOLED_Display_On_Cmd);
    timer_a0_delay(5000);
    rv += oled_128x64_send_command(SeeedOLED_Normal_Display_Cmd);
    return rv;
}

uint8_t oled_128x64_send_command(const uint8_t command)
{
    uint8_t rv;

    rv = i2cm_start();
    if (rv == I2C_OK) {
        rv += i2cm_tx(SeeedOLED_Address, I2C_WRITE);
        rv += i2cm_tx(SeeedOLED_Command_Mode, I2C_NO_ADDR_SHIFT);
        rv += i2cm_tx(command, I2C_NO_ADDR_SHIFT);
    }

    i2cm_stop();
    return rv;
}

uint8_t oled_128x64_send_data(const uint8_t data)
{
    uint8_t rv;

    rv = i2cm_start();
    if (rv == I2C_OK) {
        i2cm_tx(SeeedOLED_Address, I2C_WRITE);
        i2cm_tx(SeeedOLED_Data_Mode, I2C_NO_ADDR_SHIFT);
        i2cm_tx(data, I2C_NO_ADDR_SHIFT);
    }

    i2cm_stop();
    return rv;
/*
    Wire.beginTransmission(SeeedOLED_Address);  // begin I2C transmission
#if defined(ARDUINO) && ARDUINO >= 100
    Wire.write(SeeedOLED_Data_Mode);    // data mode
    Wire.write(Data);
#else
    Wire.send(SeeedOLED_Data_Mode);     // data mode
    Wire.send(Data);
#endif
    Wire.endTransmission();     // stop I2C transmission
    */
}

void oled_128x64_clear_display(void)
{
    unsigned char i, j;
    oled_128x64_send_command(SeeedOLED_Display_Off_Cmd);
    for (j = 0; j < 8; j++) {
        oled_128x64_set_text_xy(j, 0);
        {
            for (i = 0; i < 16; i++)    //clear all columns
            {
                oled_128x64_put_char(' ');
            }
        }
    }
    oled_128x64_send_command(SeeedOLED_Display_On_Cmd);
    oled_128x64_set_text_xy(0, 0);
}

void oled_128x64_set_brightness(const uint8_t brightness)
{
    oled_128x64_send_command(SeeedOLED_Set_Brightness_Cmd);
    oled_128x64_send_command(brightness);
}

void oled_128x64_set_horizontal_mode(void)
{
    addressing_mode = HORIZONTAL_MODE;
    oled_128x64_send_command(0x20);     //set addressing mode
    oled_128x64_send_command(0x00);     //set horizontal addressing mode
}

void oled_128x64_set_page_mode(void)
{
    addressing_mode = PAGE_MODE;
    oled_128x64_send_command(0x20);     //set addressing mode
    oled_128x64_send_command(0x02);     //set page addressing mode
}

void oled_128x64_set_text_xy(const uint8_t row, const uint8_t column)
{
    oled_128x64_send_command(0xB0 + row);       //set page address
    oled_128x64_send_command(0x00 + (8 * column & 0x0F));       //set column lower address
    oled_128x64_send_command(0x10 + ((8 * column >> 4) & 0x0F));        //set column higher address
}

void oled_128x64_put_char(uint8_t ch)
{
    if (ch < 32 || ch > 127)    //Ignore non-printable ASCII characters. This can be modified for multilingual font.
    {
        ch = ' ';               //Space
    }
    uint8_t i = 0;
    for (i = 0; i < 8; i++) {
        //read bytes from code memory
        //oled_128x64_send_data(pgm_read_byte(&BasicFont[ch - 32][i])); //font array starts at 0, ASCII starts at 32. Hence the translation
        oled_128x64_send_data(BasicFont[ch - 32][i]);   //font array starts at 0, ASCII starts at 32. Hence the translation
    }
}

void oled_128x64_put_string(const char *string)
{
    uint8_t i = 0;
    while (string[i]) {
        oled_128x64_put_char(string[i]);
        i++;
    }
}

uint8_t oled_128x64_put_number(uint32_t long_num)
{
    uint8_t char_buffer[10] = "";
    uint8_t i = 0;
    uint8_t f = 0;

    if (long_num < 0) {
        f = 1;
        oled_128x64_put_char('-');
        long_num = -long_num;
    } else if (long_num == 0) {
        f = 1;
        oled_128x64_put_char('0');
        return f;
    }

    while (long_num > 0) {
        char_buffer[i++] = long_num % 10;
        long_num /= 10;
    }

    f = f + i;
    for (; i > 0; i--) {
        oled_128x64_put_char('0' + char_buffer[i - 1]);
    }
    return f;

}

uint8_t oled_128x64_put_float(float float_number, uint8_t decimal)
{
    unsigned int temp = 0;
    float decy = 0.0;
    float rounding = 0.5;
    unsigned char f = 0;
    uint8_t i;
    if (float_number < 0.0) {
        oled_128x64_put_string("-");
        float_number = -float_number;
        f += 1;
    }
    for (i = 0; i < decimal; ++i) {
        rounding /= 10.0;
    }
    float_number += rounding;

    temp = float_number;
    f += oled_128x64_put_number(temp);
    if (decimal > 0) {
        oled_128x64_put_char('.');
        f += 1;
    }
    decy = float_number - temp; //decimal part, 
    for (i = 0; i < decimal; i++)       //4 
    {
        decy *= 10;             // for the next decimal
        temp = decy;            //get the decimal
        oled_128x64_put_number(temp);
        decy -= temp;
    }
    f += decimal;
    return f;
}

/*
unsigned char putFloat(float floatNumber)
{
    unsigned char decimal = 2;
    unsigned int temp = 0;
    float decy = 0.0;
    float rounding = 0.5;
    unsigned char f = 0;
    if (floatNumber < 0.0) {
        putString("-");
        floatNumber = -floatNumber;
        f += 1;
    }
    for (unsigned char i = 0; i < decimal; ++i) {
        rounding /= 10.0;
    }
    floatNumber += rounding;

    temp = floatNumber;
    f += putNumber(temp);
    if (decimal > 0) {
        putChar('.');
        f += 1;
    }
    decy = floatNumber - temp;  //decimal part, 
    for (unsigned char i = 0; i < decimal; i++) //4 
    {
        decy *= 10;             // for the next decimal
        temp = decy;            //get the decimal
        putNumber(temp);
        decy -= temp;
    }
    f += decimal;
    return f;
}
*/

void oled_128x64_draw_bitmap(const uint8_t * bitmaparray, const uint16_t bytes)
{
    uint8_t localAddressMode = addressing_mode;
    uint16_t i;

    if (addressing_mode != HORIZONTAL_MODE) {
        //Bitmap is drawn in horizontal mode      
        oled_128x64_set_horizontal_mode();
    }

    for (i = 0; i < bytes; i++) {
        //oled_128x64_send_data(pgm_read_byte(&bitmaparray[i]));
        oled_128x64_send_data(bitmaparray[i]);
    }

    if (localAddressMode == PAGE_MODE) {
        //If pageMode was used earlier, restore it.
        oled_128x64_set_page_mode();
    }

}

void oled_128x64_set_horizontal_scroll_properties(const uint8_t direction,
                                                  const uint8_t start_page,
                                                  const uint8_t end_page,
                                                  const uint8_t scroll_speed)
{
/*
Use the following defines for 'direction' :

 Scroll_Left			
 Scroll_Right			

Use the following defines for 'scrollSpeed' :

 Scroll_2Frames		
 Scroll_3Frames
 Scroll_4Frames
 Scroll_5Frames	
 Scroll_25Frames
 Scroll_64Frames
 Scroll_128Frames
 Scroll_256Frames

*/

    if (Scroll_Right == direction) {
        //Scroll Right
        oled_128x64_send_command(0x26);
    } else {
        //Scroll Left  
        oled_128x64_send_command(0x27);

    }
    oled_128x64_send_command(0x00);
    oled_128x64_send_command(start_page);
    oled_128x64_send_command(scroll_speed);
    oled_128x64_send_command(end_page);
    oled_128x64_send_command(0x00);
    oled_128x64_send_command(0xFF);
}

void oled_128x64_activate_scroll(void)
{
    oled_128x64_send_command(SeeedOLED_Activate_Scroll_Cmd);
}

void oled_128x64_deactivate_scroll(void)
{
    oled_128x64_send_command(SeeedOLED_Dectivate_Scroll_Cmd);
}

void oled_128x64_set_normal_display(void)
{
    oled_128x64_send_command(SeeedOLED_Normal_Display_Cmd);
}

void oled_128x64_set_inverse_display(void)
{
    oled_128x64_send_command(SeeedOLED_Inverse_Display_Cmd);
}
